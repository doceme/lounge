<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>schema.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AbstractBaseModel.html">AbstractBaseModel</a><ul class='methods'><li data-type='method'><a href="AbstractBaseModel.html#clear">clear</a></li><li data-type='method'><a href="AbstractBaseModel.html#clearErrors">clearErrors</a></li><li data-type='method'><a href="AbstractBaseModel.html#get">get</a></li><li data-type='method'><a href="AbstractBaseModel.html#getErrors">getErrors</a></li><li data-type='method'><a href="AbstractBaseModel.html#hasErrors">hasErrors</a></li><li data-type='method'><a href="AbstractBaseModel.html#inspect">inspect</a></li><li data-type='method'><a href="AbstractBaseModel.html#set">set</a></li><li data-type='method'><a href="AbstractBaseModel.html#toJSON">toJSON</a></li><li data-type='method'><a href="AbstractBaseModel.html#toObject">toObject</a></li><li data-type='method'><a href="AbstractBaseModel.html#toString">toString</a></li></ul></li><li><a href="BaseModel.html">BaseModel</a></li><li><a href="CouchbaseDocument.html">CouchbaseDocument</a><ul class='methods'><li data-type='method'><a href="CouchbaseDocument.html#.findById">findById</a></li><li data-type='method'><a href="CouchbaseDocument.html#.remove">remove</a></li><li data-type='method'><a href="CouchbaseDocument.html#getCAS">getCAS</a></li><li data-type='method'><a href="CouchbaseDocument.html#getDocumentKeyKey">getDocumentKeyKey</a></li><li data-type='method'><a href="CouchbaseDocument.html#getDocumentKeyValue">getDocumentKeyValue</a></li><li data-type='method'><a href="CouchbaseDocument.html#index">index</a></li><li data-type='method'><a href="CouchbaseDocument.html#remove">remove</a></li><li data-type='method'><a href="CouchbaseDocument.html#removeIndexes">removeIndexes</a></li><li data-type='method'><a href="CouchbaseDocument.html#save">save</a></li></ul></li><li><a href="Document.html">Document</a><ul class='methods'><li data-type='method'><a href="Document.html#.getDocumentKeyValue">getDocumentKeyValue</a></li><li data-type='method'><a href="Document.html#getDocumentKeyKey">getDocumentKeyKey</a></li><li data-type='method'><a href="Document.html#getDocumentKeyValue">getDocumentKeyValue</a></li></ul></li><li><a href="Lounge.html">Lounge</a><ul class='methods'><li data-type='method'><a href="Lounge.html#connect">connect</a></li><li data-type='method'><a href="Lounge.html#disconnect">disconnect</a></li><li data-type='method'><a href="Lounge.html#getModel">getModel</a></li><li data-type='method'><a href="Lounge.html#getOption">getOption</a></li><li data-type='method'><a href="Lounge.html#model">model</a></li><li data-type='method'><a href="Lounge.html#modelNames">modelNames</a></li><li data-type='method'><a href="Lounge.html#schema">schema</a></li><li data-type='method'><a href="Lounge.html#setOption">setOption</a></li></ul></li><li><a href="MemoDriver.html">MemoDriver</a></li><li><a href="Model.html">Model</a><ul class='methods'><li data-type='method'><a href="Model.html#getCAS">getCAS</a></li><li data-type='method'><a href="Model.html#getDocumentKeyKey">getDocumentKeyKey</a></li><li data-type='method'><a href="Model.html#getDocumentKeyValue">getDocumentKeyValue</a></li><li data-type='method'><a href="Model.html#index">index</a></li><li data-type='method'><a href="Model.html#remove">remove</a></li><li data-type='method'><a href="Model.html#removeIndexes">removeIndexes</a></li><li data-type='method'><a href="Model.html#save">save</a></li></ul></li><li><a href="ModelInstance.html">ModelInstance</a><ul class='methods'><li data-type='method'><a href="ModelInstance.html#getCAS">getCAS</a></li><li data-type='method'><a href="ModelInstance.html#getDocumentKeyKey">getDocumentKeyKey</a></li><li data-type='method'><a href="ModelInstance.html#getDocumentKeyValue">getDocumentKeyValue</a></li><li data-type='method'><a href="ModelInstance.html#index">index</a></li><li data-type='method'><a href="ModelInstance.html#remove">remove</a></li><li data-type='method'><a href="ModelInstance.html#removeIndexes">removeIndexes</a></li><li data-type='method'><a href="ModelInstance.html#save">save</a></li></ul></li><li><a href="ObjectArray.html">ObjectArray</a></li><li><a href="PlainBaseModel.html">PlainBaseModel</a></li><li><a href="Schema.html">Schema</a><ul class='methods'><li data-type='method'><a href="Schema.html#add">add</a></li><li data-type='method'><a href="Schema.html#extend">extend</a></li><li data-type='method'><a href="Schema.html#get">get</a></li><li data-type='method'><a href="Schema.html#getDocumentKeyValue">getDocumentKeyValue</a></li><li data-type='method'><a href="Schema.html#getRefKey">getRefKey</a></li><li data-type='method'><a href="Schema.html#hasRefPath">hasRefPath</a></li><li data-type='method'><a href="Schema.html#method">method</a></li><li data-type='method'><a href="Schema.html#post">post</a></li><li data-type='method'><a href="Schema.html#pre">pre</a></li><li data-type='method'><a href="Schema.html#set">set</a></li><li data-type='method'><a href="Schema.html#static">static</a></li><li data-type='method'><a href="Schema.html#virtual">virtual</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">schema.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import _ from 'lodash';
import clone from 'clone';

import * as utils from './utils';
import * as schemaUtils from './schema.utils';
import { normalizeProperties } from './normalize';

export default class Schema {
  /**
   * @classdesc Schema class represents the schema definition. It includes properties, methods, static methods, and any
   * middleware we want to define.
   *
   * @description Creates an object schema
   * @class
   * @public
   * @param {Object} descriptor - the schema definition
   * @param {Object} options
   * @param {Boolean} options.strict - By default (&lt;code>true&lt;/code>), allow only values in the schema to be set.
   *                                   When this is &lt;code>false&lt;/code>, setting new fields will dynamically add the field
   *                                   to the schema as type "any".
   * @param {Boolean} options.dotNotation - Allow fields to be set via dot notation. Default: &lt;code>true&lt;/code>.
   *                                      &lt;code>obj['user.name'] = 'Joe'; -> obj: { user: 'Joe' }&lt;/code>
   *
   * @param {Boolean} options.minimize - "minimize" schemas by removing empty objects. Default: &lt;code>true&lt;/code>
   * @param {Object} options.toObject - &lt;code>toObject&lt;/code> method options.
   * @param {Boolean} options.toObject.minimize - "minimize" schemas by removing empty objects. Default: &lt;code>true&lt;/code>
   * @param {Function} options.toObject.transform - transform function
   * @param {Boolean} options.toObject.virtuals - whether to include virtual properties. Default: &lt;code>false&lt;/code>
   * @param {Boolean} options.toObject.dateToISO - convert dates to string in ISO format using &lt;code>Date.toISOString()&lt;/code>. Default:  &lt;code>false&lt;/code>
   * @param {Object} options.toJSON - options for &lt;code>toJSON&lt;/code> method options, similar to above
   * @param {Boolean} options.strict - ensures that value passed in to assigned that were not specified in our
   *                                   schema do not get saved
   * @param {Function} options.onBeforeValueSet - function called when write operations on an object takes place. Currently,
   * it will only notify of write operations on the object itself and will not notify you when child objects are written to.
   * If you return false or throw an error within the onBeforeValueSet handler, the write operation will be cancelled.
   * Throwing an error will add the error to the error stack.
   * @param {Function} options.onValueSet - Similar to &lt;code>onBeforeValueSet&lt;/code>, but called after we've set a value on the key,
   *
   * @example
   * var schema = new lounge.Schema({ name: String });
   * @example &lt;caption>with &lt;code>onBeforeValueSet&lt;/code>&lt;/caption>
   * var User = lounge.schema({ name: String }, {
   *   onBeforeValueSet: function(key, value) {
   *     if(key === 'name' &amp;&amp; value.indexOf('Joe') >= 0) {
   *       return false;
   *     });
   *   }
   * });
   *
   * var User = lounge.model('User', schema);
   * var user = new User();
   * user.name = 'Bill'; // name not set
   * user.name = 'Joe Smith'; //  { name: 'Joe Smith' }
   */
  constructor(descriptor, options = {}) {
    // Create object for options if doesn't exist and merge with defaults.
    this.options = _.extend({
      strict: true,
      dotNotation: true
    }, options);

    this.methods = {};
    this.statics = {};
    this.hooks = {};
    this.refs = {};
    this.indexes = {};

    // document key settings
    this.key = {
      docKeyKey: '',
      prefix: null,
      suffix: null,
      generate: true
    };

    this.add(descriptor);

    // apply these if needed
    if (!this.key.prefix &amp;&amp; _.isString(this.options.keyPrefix)) {
      this.key.prefix = this.options.keyPrefix;
    }

    if (!this.key.suffix &amp;&amp; _.isString(this.options.keySuffix)) {
      this.key.suffix = this.options.keySuffix;
    }
  }

  /*!
   * Apply document key from descriptor
   * @param descriptor
   */
  _applyDocumentKey(descriptor) {
    // find the document key key
    let docKeyFound = false;
    for (const prop in descriptor) {
      if (descriptor.hasOwnProperty(prop)) {
        if (utils.isPlainObject(descriptor[prop]) &amp;&amp; descriptor[prop].key === true) {
          if (descriptor[prop].index === true) {
            throw new TypeError('Schema key cannot be index field');
          }

          if (descriptor[prop].ref) {
            throw new TypeError('Schema key cannot be reference property');
          }

          if (descriptor[prop].type &amp;&amp;
            descriptor[prop].type !== String &amp;&amp;
            descriptor[prop].type !== Number &amp;&amp;
            descriptor[prop].type !== 'number' &amp;&amp;
            descriptor[prop].type !== 'string') {
            throw new TypeError('Schema expects key to be a String or a Number');
          }

          docKeyFound = true;
          this.key.generate = false;

          this.key.docKeyKey = prop;
          if (_.isString(descriptor[prop].prefix)) {
            this.key.prefix = descriptor[prop].prefix;
          }

          if (_.isString(descriptor[prop].suffix)) {
            this.key.suffix = descriptor[prop].suffix;
          }

          if (_.isBoolean(descriptor[prop].generate)) {
            this.key.generate = descriptor[prop].generate;
          }

          this.descriptor[this.key.docKeyKey] = normalizeProperties.call(this, descriptor[prop], this.key.docKeyKey);
        }
      }
    }

    if (!docKeyFound &amp;&amp; !this.key.docKeyKey) {
      // manually add one, should be one-op
      this.key.docKeyKey = 'id';
      this.descriptor[this.key.docKeyKey] = normalizeProperties.call(this, String, this.key.docKeyKey);
    }
  }

  /*!
   * Find all embedded documents
   * @param descriptor
   */
  _getRefs(descriptor) {
    const refs = schemaUtils.getRefs(descriptor);
    if (refs &amp;&amp; refs.length > 0) {
      refs.forEach((elem) => {
        this.refs[elem.path] = elem;
      });
    }
  }

  /*!
   * Find all indexes
   * @param descriptor
   */
  _getIndexes(descriptor) {
    const inds = schemaUtils.getIndexes(descriptor);

    if (inds &amp;&amp; inds.length > 0) {
      inds.forEach((elem) => {
        this.indexes[elem.path] = elem;
      });
    }
  }

  /**
   * Creates a instance method for the created model.
   * An object of function names and functions can also be passed in.
   *
   * @public
   * @param {String} name the name of the method
   * @param {Function} func the actual function implementation
   *
   * @example
   * var userSchema = lounge.schema({
   *   firstName: String,
   *   lastName: String
   * });
   *
   * userSchema.method('getFullName', function () {
   *   return this.firstName + ' ' + this.lastName
   * });
   *
   * var User = lounge.model('User', userSchema);
   * var user = new User({
   *   firstName: 'Joe',
   *   lastName: 'Smith'
   * });
   *
   * console.log(user.getFullName()); // Joe Smith
   */
  method(name, func) {
    if (_.isPlainObject(name)) {
      for (func in name) {
        if ({}.hasOwnProperty.call(name, func)) {
          this.method(func, name[func]);
        }
      }
    } else {
      if (!_.isString(name)) {
        throw new TypeError('Schema#method expects a string identifier as a function name');
      } else if (!_.isFunction(func)) {
        throw new TypeError('Schema#method expects a function as a handle');
      }

      this.methods[name] = func;
    }
  }

  /**
   * Creates a static function for the created model.
   * An object of function names and functions can also be passed in.
   *
   * @public
   * @param {String} name name of the statuc function
   * @param {Function} func the actual function
   *
   * @example
   * var userSchema = lounge.schema({ name: String });
   * userSchema.static('foo', function () {
   *   return 'bar';
   * });
   *
   * var User = lounge.model('User', userSchema);
   *
   * console.log(User.foo()); // 'bar'
   */
  static(name, func) {
    if (_.isPlainObject(name)) {
      for (func in name) {
        if ({}.hasOwnProperty.call(name, func)) {
          this.static(func, name[func]);
        }
      }
    } else {
      if (!_.isString(name)) {
        throw new TypeError('Schema#statics expects a string identifier as a function name');
      } else if (!_.isFunction(func)) {
        throw new TypeError('Schema#statics expects a function as a handle');
      }

      this.statics[name] = func;
    }
  }

  /**
   * Creates a virtual property for the created model with the given object
   * specifying the get and optionally set function
   *
   * @public
   * @param {String} name name of the virtual property
   * @param {String|Function|Object} type optional type to be used for the virtual property. If not provided default is
   *                                      &lt;code>'any'&lt;/code> type.
   * @param {Object} options virtual options
   * @param {Function} options.get - the virtual getter function
   * @param {Function} options.set - the virtual setter function. If not provided the virtual becomes read-only.
   *
   * @example
   * var userSchema = lounge.schema({firstName: String, lastName: String});
   *
   * userSchema.virtual('fullName', String, {
   *   get: function () {
   *     return this.firstName + ' ' + this.lastName;
   *   },
   *   set: function (v) {
   *     if (v !== undefined) {
   *       var parts = v.split(' ');
   *       this.firstName = parts[0];
   *       this.lastName = parts[1];
   *     }
   *   }
   * });
   *
   * var User = lounge.model('User', userSchema);
   *
   * var user = new User({firstName: 'Joe', lastName: 'Smith'});
   * console.log(user.fullName); // Joe Smith
   * user.fullName = 'Bill Jones';
   * console.log(user.firstName); // Bill
   * console.log(user.lastName); // Jones
   * console.log(user.fullName); // Bill Jones
   */
  virtual(name, type, options) {
    if (!_.isString(name)) {
      throw new TypeError('Schema#virtual expects a string identifier as a property name');
    }

    if (_.isPlainObject(type) &amp;&amp; !options) {
      options = type;
      type = 'any';
    } else if (!_.isPlainObject(options)) {
      throw new TypeError('Schema#virtual expects an object as a handle');
    } else if (!_.isFunction(options.get)) {
      throw new TypeError('Schema#virtual expects an object with a get function');
    }

    const virtualType = {
      type,
      virtual: true,
      get: options.get,
      invisible: true
    };

    if (options.set) {
      virtualType.set = options.set;
    } else {
      virtualType.readOnly = true;
    }

    this.descriptor[name] = virtualType;
  }

  /**
   * Sets/gets a schema option.
   *
   * @param {String} key option name
   * @param {Object} [value] if not passed, the current option value is returned
   * @public
   */
  set(key, value) {
    if (arguments.length === 1) {
      return this.options[key];
    }

    this.options[key] = value;

    return this;
  }

  /**
   * Gets a schema option.
   *
   * @public
   * @param {String} key option name
   * @return {*} the option value
   */
  get(key) {
    return this.options[key];
  }

  /**
   * Defines a pre hook for the schema.
   * See {@link https://www.github.com/bojand/grappling-hook grappling-hook}.
   */
  pre(name, fn) {
    this._hook('pre', name, fn);
  }

  /**
   * Defines a post hook for the schema.
   * See {@link https://www.github.com/bojand/grappling-hook grappling-hook}.
   */
  post(name, fn) {
    this._hook('post', name, fn);
  }

  _hook(hook, name, fn) {
    if (this.hooks[`${hook}:${name}`] &amp;&amp; Array.isArray(this.hooks[`${hook}:${name}`].fns)) {
      this.hooks[`${hook}:${name}`].fns.push(fn);
    } else {
      this.hooks[`${hook}:${name}`] = {
        hook,
        name,
        fns: [fn]
      };
    }
  }

  /**
   * Adds the descriptor to the schema at the given key. Or add an &lt;code>object&lt;/code> as a descriptor.
   * @param {String|Object }key the property key
   * @param {Object} descriptor the property descriptor
   *
   * @example
   * var userSchema = lounge.schema({firstName: String });
   * userSchema.add('lastName', String);
   * userSchema.add({ email: String });
   */
  add(key, descriptor) {
    if (!this.descriptor) {
      this.descriptor = {};
    }

    // adjust our descriptor
    if (key &amp;&amp; descriptor) {
      this._getRefs(descriptor);
      this._getIndexes(descriptor);
      this.descriptor[key] = normalizeProperties.call(this, descriptor, key);
    } else if (typeof key === 'object' &amp;&amp; !descriptor) {
      this._getRefs(key);
      this._getIndexes(key);

      _.each(key, (properties, index) => {
        this.descriptor[index] = normalizeProperties.call(this, properties, index);
      });
    }

    this._applyDocumentKey(this.descriptor);
  }

  /**
   * Clones property from other to us
   * @param {Schema} other - other schema
   * @param {String} prop - property name
   * @param {Boolean} add - whether to add() or assign. if true will do deep clone.
   * @private
   */
  _cloneProp(other, prop, add) {
    if (other &amp;&amp; other[prop]) {
      let p;
      for (p in other[prop]) {
        if (other[prop].hasOwnProperty(p) &amp;&amp; !this[prop][p]) {
          if (add) {
            this.add(p, clone(other.descriptor[p]));
          } else {
            this[prop][p] = other[prop][p];
          }
        }
      }
    }
  }

  /**
   * Extends other schema. Copies descriptor properties, methods, statics, virtuals and middleware.
   * If this schema has a named property already, the property is not copied.
   * @param {Schema} other the schema to extend.
   */
  extend(other) {
    if (other &amp;&amp; other instanceof Schema) {
      this._cloneProp(other, 'descriptor', true);
      this._cloneProp(other, 'statics');
      this._cloneProp(other, 'methods');

      // options
      let k;
      for (k in other.options) {
        if (other.options.hasOwnProperty(k)) {
          const ours = this.get(k);
          const theirs = other.options[k];
          if (_.isUndefined(ours)) {
            this.set(k, clone(theirs));
          } else if (_.isPlainObject(ours) &amp;&amp; _.isPlainObject(theirs)) {
            const dest = clone(theirs);
            this.set(k, _.merge(dest, ours));
          }
        }
      }

      _.forEach(_.values(other.hooks), hook => {
        _.forEach(hook.fns, fn => {
          this[hook.hook](hook.name, fn);
        });
      });
    }

    return this;
  }

  /**
   * Helper function to get the document key
   * @param {String} id the id
   * @param {Boolean} full If &lt;code>true&lt;/code> the full expanded value of the key will be returned if there were any suffix and / or prefix
   * defined in schema they are also applied. We test if the passed in id already satisfies expansion.
   * @returns {String}
   * @example
   * var schema = lounge.schema({ email: String }, {keyPrefix: 'user::' });
   * console.log(schema.getDocumentKeyValue('114477a8-1901-4146-8c90-0fc9eec57a58', true)); // user::114477a8-1901-4146-8c90-0fc9eec57a58
   * console.log(schema.getDocumentKeyValue('user::114477a8-1901-4146-8c90-0fc9eec57a58', true)); // user::114477a8-1901-4146-8c90-0fc9eec57a58
   * console.log(schema.getDocumentKeyValue('user::114477a8-1901-4146-8c90-0fc9eec57a58', false)); // 114477a8-1901-4146-8c90-0fc9eec57a58
   * console.log(schema.getDocumentKeyValue('114477a8-1901-4146-8c90-0fc9eec57a58', false)); // 114477a8-1901-4146-8c90-0fc9eec57a58
   */
  getDocumentKeyValue(id, full) {
    if (_.isString(id)) {
      const prefix = _.isString(this.key.prefix) ? this.key.prefix : '';
      const suffix = _.isString(this.key.suffix) ? this.key.suffix : '';

      const re = new RegExp(`^${prefix}.*${suffix}$`);
      const test = re.test(id);

      if (full) {
        if (test) {
          return id;
        }

        return prefix.concat(id, suffix);
      }

      if (test) {
        id = id.replace(new RegExp(`^${prefix}`), '');
        id = id.replace(new RegExp(`${suffix}$`), '');
      }
    }

    return id;
  }

  /**
   * Gets the reference document key value
   * @param {String} name - index name
   * @param {String} v - index value
   * @returns {string}
   */
  getRefKey(name, v) {
    const d = this.options.delimiter;
    const kp = this.options.keyPrefix || '';
    return kp.concat(this.options.refIndexKeyPrefix || '', name, d, v);
  }

  /**
   * Returns whether this schema has the specified reference path
   * @param {String} path path to check
   * @returns {boolean}
   */
  hasRefPath(path) {
    let ret = false;
    if (this.refs &amp;&amp; path) {
      path = path.toLowerCase();
      for (const key in this.refs) {
        if (this.refs.hasOwnProperty(key) &amp;&amp; this.refs[key].path.toLowerCase() === path) {
          ret = true;
          break;
        }
      }
    }

    return ret;
  }
}
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Mon Sep 05 2016 21:52:15 GMT-0300 (ADT) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
